### 1. Greedy(그리디)
* 탐욕적으로 문제를 해결하는 알고리즘.
* **'현재 상황에서 지금 당장 좋은 것만 고르는 방법'** 
* 그리디 알고리즘을 이용하면 매 순간 가장 좋아 보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.
* 다익스트라 알고리즘도 엄밀히 말하면 그리디 알고리즘이다.
* 특정문제를 보았을 때 단순 현재 상황에서 가장 좋아보이는 것만을 선택해도 문제를 풀수 있는지를 파악할 수 있어야 한다.
* 문제에서 **'가장 큰 순서대로'**, **'가장 작은 순서대로'** 기준을 제시해준다.
* 그리디 알고리즘은 자주 **정렬 알고리즘**과 짝을 이뤄 출제가 된다.

### 2. 구현
* 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
* 모든 경우의 수를 주저 없이 다 계산하는 해결 방법을 완전 탐색이라 한다.
* 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행해야 하는 문제 유형을 시뮬레이션이라고 한다.
* 구현시 고려해야할 사항으로 C/C++에서는 메모리 제약사항과 파이썬에서는 리스트의 크기를 신경써줘야 한다.

### 3. 자료구조의 기초
* 탐색(Search) : 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
	* 그래프, 트리 등의 자료구조를 말하며 DFS, BFS가 대표적인 탐색 알고리즘이다.
* 자료구조(Data Structure) : 데이터를 표현하고 관리하고 처리하기 위한 구조
	* 스택, 큐가 자료구조의 기초 개념이며 삽입과 삭제가 핵심적인 함수로 구성된다.
	* 스택과 큐를 사용할 때는 삽입(Push)과 삭제(Pop) 외에서 오버플로와 언더플로를 고민해줘야 한다
	* 오버플로(Overflow) : 자료구조가 수용할 수 있는 데이터의 크기를 이미 가득 찬 상태에서 삽입연산을 수행할 때 발생
	* 언더플로(Underflow) : 자료구조에 데이터가 전혀 들어 있지 않은 상태에서 삭제 연산을 수행하면 데이터가 전혀 없는 상태이므로 언더플로가 발생한다.

* 스택(Stack) : 선입후출(FILO)구조 또는 후입선출(LIFO)구조를 말한다.
	* 파이썬에서는 스택을 이용할 때 별도의 라이브러리를 사용할 필요가 없다.
	* 기본 리스트에서 append() 와 pop()을 이용하면 스택 자료구조와 동일하게 동작한다.

* 큐(Queue) : 선입선출(FIFO)구조이다.
	* 파이썬에서 큐를 구현할 때는 collections 모듈에서 제공하는 deque 자료구조를 활용하자.

* 재귀함수(Recursive) : 자기 자신을 다시 호출하는 함수를 의미한다.
	* 재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수가 언제 끝날지, 종료 조건을 꼭 명시해야 한다. 종료조건을 명시하지 않으면 함수가 무한 호출이 될 수 있다.
	* 재귀함수는 내부적으로 스택 자료구조와 동일하다.
	* 재귀함수는 반복문을 이용하는 것과 비교하였을 대 보다 간결해진다.

### 4. 탐색알고리즘 DFS / BFS
* 그래프(Graph)의 기본 구조
	* 그래프는 노드(Node)와 간선(Edge)로 표현되며, 이때 노드를 정점(Vertex)이라고 말한다.
	* 인접 행렬(Adjacency Matrix) : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
	* 인접 리스트(Adjacency List) : 리스트로 그래프의 연결 관계를 표현하는 방식
	* 인접 행렬 방식은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비가 된다.
	* 인접리스트 방식은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용한다.
	* 인접리스트는 두 노드가 연결되었는지에 대한 정보를 얻는 속도가 느리다. 왜냐하면 하나하나 연결된 데이터를 하나씩 확인해야하기 때문이다.
	* 모든 인접 노드를 순회해야 하는 경우, 인접리스트방식이 인접 행렬 방식에 비해 메모리 공간의 낭비가 적다.

* DFS(Depth First Search) 깊이우선탐색 알고리즘
	* 깊이 우선 탐색 알고리즘은 DFS는 스택 자료구조에 기초한다.
	* 시간복잡도는 O(N)이다.	
	* 스택을 이용하는 알고리즘이기 때문에 실제 구현은 재귀함수를 이용하면 매우 간결하게 구현할 수 있다.

~~~
1. 탐색 시작 노드를 스택에 삽입하고 방문처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있다면 그 인접 노드를 스택에 넣고 방문처리를 한다. 방문하지 않은 인접노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번의 과정을 더이상 수행할 수 없을 때까지 반복한다.
~~~

* BFS(Breadth First Search) 너비우선탐색 알고리즘
	* 가까운 노드부터 탐색하는 알고리즘이다.
	* 선입선출(FIFO)방식인 큐 자료구조를 이용하는 것이 정석이다.
	* deque 라이브러리를 사용하는것이 좋으며 탐색을 수행함에 있어 O(N)의 시간이 소요된다.
	* 실제 수행 시간은 DFS보다 좋은편이다.

~~~
1. 탐색 시작 노드를 큐에 삽입하고 방문처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다. 
~~~


### 5. 기준에 따라 데이터를 정렬
* 정렬 알고리즘 개요
	* 정렬(Sorting) : 데이터를 특정한 기준에 따라서 순서대로 나열하는것을 말한다.  
	* 프로그램에서 데이터를 가공할 때 오름차순, 내림차순으로 정렬해서 사용하는 경우가 많다.
	* 정렬 알고리즘으로 데이터를 정렬하면 이진탐색(Binary Search)이 가능해진다.
	* 종류 : 선택정렬, 삽입정렬, 퀵정렬, 계수정렬 등
	* 면접에서도 단골로 굉장히 자주 나온다.

* 선택정렬(Selection Sort)
	* 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두번째 데이터와 바꾸는 과정을 통해 점점 작은 데이터를 앞에 두는 알고리즘이다.
	* 가장 원시적인 방법이며, 매번 가장 작은것을 선택한다.
	* 시간복잡도는 O(N^2)이다.

* 삽입정렬(Insertion Sort)
	* 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하는 알고리즘이다.
	* 삽입정렬은 필요할 때만 위치를 바꾸므로 '데이터가 거의 정렬 되었을 때' 효율적이다.
	* 정렬이 이루어진 원소는 항상 오름차순을 유지하고 있다.
	* 자기보다 작은 데이터를 만나면 더 이상 데이터를 살펴보지 않고 그 자리에 삽입한다.
	* 시간복잡도는 O(N^2)이지만, 거의 정렬되어 있는 경우 다른 알고리즘 보다 강력한 O(N)의 시간복잡도를 가진다.

* 퀵정렬(Quick Sort)
	* 지금까지 나온 정렬 알고리즘 중에서 가장많이 사용되는 알고리즘이다.
	* 퀵정렬과 비교할 만큼 빠른 '병합정렬' 알고리즘이 있다.
	* 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾼후 리스트를 반으로 나누는 방식을 퀵정렬 알고리즘이라고 한다. 
	* 기준 데이터를 피벗(Pivot)이라고 부른다.
	* 특정한 리스트에서 피벗을 설정하여 정렬을 수행한 후, 다시 피벗을 기준으로 왼쪽 리스트와 오른쪽 리스트에서 각각 다시 정렬을 수행한다. 이 과정은 '재귀함수' 동작 원리와 같다. 끝나는 조건은 리스트의 데이터 개수가 1개인 경우 재귀가 멈춘다.
	* 퀵정렬의 시간복잡도는 O(NlogN)이지만 최악의 경우 O(N^2)이다.
	* 최악의 경우에는 이미 리스트가 정렬이 되어있는 경우를 말한다.

* 계수정렬(Count Sort)
	* 다음과 같은 특정한 조건에 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.
	* 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용할 수 있다.
	* 일반적으로는 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용이 가능하다.
	* 계수정렬은 모든 범위를 담을 수 있는 크기의 배열을 미리 선언한다.
	* 계수정렬의 시간복잡도는 O(N+K)이다. 조건에만 부합하다면 현존하는 정렬 알고리즘 중 기수정렬(Radix Sort)과 더불어 가장 빠르다.
	* 기수정렬의 경우 계수정렬에 비해 동작은 느리지만 처리할 수 있는 정수의 크기가 더 크다.
	* 계수정렬의 공간복잡도는 O(N+K)이다. 문제에 따라서 동일한 값을 가지는 데이터가 여러개일 경우 효과적으로 동작하지만 극단적으로 0, 999,999와 같은 단 2개만 있다고 한다면 계수정렬에서 리스트의 크기가 100만개가 되어야 하므로 항상 사용할 수 있는 정렬 알고리즘은 아니며 상황을 보며 써야한다.

* 파이썬에서 제공하는 정렬 라이브러리
	* 기본으로 제공하는 정렬라이브러리인 sorted()함수는 퀵정렬과 동작방식이 비슷한 병합정렬을 기반으로 만들어져서 일반적인 퀵정렬보다는 느리지만 최악의 경우에도 O(NlogN)시간복잡도를 보장한다.

* 코딩테스트에서의 정렬
	* 정렬 라이브러리로 풀 수 있는 문제 : 단순히 정렬 기법을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용법을 숙지하면 쉽게 해결한다.
	* 정렬 알고리즘의 원리에 대해서 물어보는 문제 : 선택정렬, 삽입정렬, 퀵정렬 등의 원리를 알아야 풀 수 있다.
	* 더 빠른 정렬이 필요한 문제 : 퀵정렬 기반의 정렬 기법으로는 풀 수가 없으며, 계수정렬 등의 다른 알고리즘을 사용하거나 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.

### 6. 이진탐색
* 순차탐색(Sequential Search)
	* 가장 기본적인 탐색 방법이다. 
	* 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법이다.
	* 보통 정렬되지 않은 리스트에서 데이터를 찾아야 할 때 사용한다. 
	* 리스트의 데이터에 하나씩 방문하며 특정한 문자열과 같은지 검사하므로 구현도 간단하다.
	* 리스트에 특정 값의 원소가 있는지 체크할 때 순차탐색으로 원소를 확인한다.
	* 리스트 자료형에서 특정한 값을 가지는 원소의 개수를 세는 count메서드를 이용할 때도 내부에서는 순차탐색이 수행된다.
	* 정렬 여부와 상관없이 가장 앞에 있는 원소부터 하나씩 확인해야 한다는 점이 특징.
	* 데이터의 개수가 N개일 때 최대 N번의 비교 연산이 필요하므로 순차탐색의 최악의 경우 시간복잡도는 O(N)이다.

* 이진탐색(Binary Search) : 반으로 쪼개면서 탐색하기
	* 배열 내부의 데이터가 정렬되어 있어야만 사용할 수 있다.
	* 이미 정렬되어 있다면 매우 빠르게 데이터를 찾을 수 있다는 특징이 있다.
	* 이진 탐색은 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 특징이 있다.
	* 변수 3개를 사용한다. 시작점, 중간점, 끝점.
	* 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를  찾는 게 이진탐색 과정이다.
	* 확인하는 원소의 개수가 절반씩 줄어든다는 점에서 시간복잡도는 O(logN)이다.
	* 이진탐색을 구현하는 방법에는 2가지 방법이 있다.
		1. 재귀함수 이용.
		2. 단순하게 반복문을 이용.

* 트리자료구조 : 트리 자료구조 중에서 가장 간단한 형태가 이진탐색트리이다.
	* 트리는 부모노드와 자식노드의 관계로 표현된다.
	* 트리의 최상단 노드를 루트 노드라고 한다.
	* 트리의 최하단 노드를 단말 노드라고 한다.
	* 트리에서 일부를 떼어내도 트리 구조이며 이를 버스트리라 한다.
	* 트리는 파일 시스템과 같이 계층적이고 정렬된 데이터를 다루기에 적합하다.

* 빠르게 입력받기
	* 입력데이터의 개수가 많은 문제에 input()을 사용하면 동작속도가 느려서 시간초과로 오답판정을 받을 수가 있다.
	* 이때 sys라이브러리의 readline()함수를 이용하면 시간초과를 피할 수 있다.
	* readline()으로 입력하게 되면 엔터가 개행으로 입력된다. 이때 rstrip()함수를 통해서 마지막 개행을 제거해줘야한다.
~~~
import sys

input_data = sys.stdin.readline().rstrip()

print(input_data)
~~~

### 7.다이나믹 프로그래밍(Dynamic Programming) - 중복되는 연산을 줄이자!
* 컴퓨터를 활용해도 해결하기 어려운 문제란?!
	* 최적의 해를 구하기에 시간이 매우 많이 필요할때
	* 메모리 공간이 매우 많이 필요한 문제
	=> 컴퓨터도 연산속도에 한계가 있으며 메모리 공간을 사용할 수 있는 데이터의 개수도 한정적이다.!! 따라서 속도와 공간을 최대한 활용하는 효율적인 알고리즘을 사용해야 한다.

* 다이나믹 프로그래밍은 다음조건을 만족할 때 사용할 수 있다.
	* 큰 문제를 작은 문제로 나눌수 있는 경우
	* 작은 문제에서 구한 정답이 큰 문제를 해결하고자 동일하게 쓰이는 경우

* 메모이제이션(Memoization) 기법
	* 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, 한 번 구한 결과를 메모리 공간에 저장해두고 같은 식을 다시 호출하는 알고리즘 방법
	* 메모이제이션은 값을 저장하는 방법이므로 캐싱(Caching)이라고 한다.

* 분할정복(Divide and Conquer)과 다이나믹 프로그래밍의 차이점
	* 다이나믹 프로그래밍 문제는 서로 영향을 미친다.
	* ex) 퀵정렬을 예로 한번 기준 원소(pivot)의 자리를 변경해서 자리를 잡게 되면 그 기준원소의 위치는 더 이상 바뀌지 않고 그 피벗값을 다시 처리하는 부분 문제는 존재하지 않는다. 하지만 다이나믹 프로그래밍은 한 번 해결했던 문제를 저장을 해두고 필요에 따라 문제를 다시 해결한다는 점이있다.

* 다이나믹 프로그래밍의 시간복잡도
	* 다이나믹 프로그래밍에서 재귀 함수를 사용하면 컴퓨터 시스템에서는 함수를 다시 호출했을 때 메모리상에 적재되는 일련의 과정을 따라야 하므로 오버헤드가 발생할 수 있다.
	* 일반적으로 반복문을 이용한 다이나믹 프로그래밍이 더 성능이 좋다.
	* 다이나믹 프로그래밍을 적용했을 때 시간복잡도는 O(N)이다.

* 다이나믹 프로그래밍의 종류
	* 탑다운(Top-Down) : 큰 문제를 해결하기 위해 작은 문제를 호출하여 접근하는 방법
	* 보텀업(Botton-Up) : 작은 문제부터 차근차근 답을 도출하여 접근하는 방법
	* 탑다운의 경우 보통 재귀방식이고 보텀업의 경우는 반복문을 이용한다.
	* 탑다운의 경우 메모이제이션(Memoization)이라고 하양식이로고도 하며, 보텀업은 상향식이라고 한다.
	* 탑다운방식에서 사용되는 결과 저장용 리스트는 메모이제이션이라고 한다.
	* 보텀업방식에서 사용되는 결과 저장용 리스트는 DP테이블이라고 한다.

* 코딩테스트에서의 다이나믹 프로그래밍
	* 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인해보자
	* 가능하다면 재귀함수를 이용하는 탑다운 방식보다는 보텀업 방식으로 구현하는게 권장이된다. 시스템상 재귀 함수의 스택크기가 한정되어 있기 때문이다.
	* 파이썬에서 재귀함수를 5000이상의 깊이로 구현할 경우 깊이(Depth)와 관련된 오류가 발생할 수 있다. 그럴경우 sys라이브러리에 있는 setrecursionlimit()함수를 호출하여 재귀 제한을 완화시키자.

### 8. 최단경로(Shortest Path) 알고리즘
* 가장 빠르게 도달하는 방법
	* 최단경로 알고리즘은 말 그대로 가장 짧은 경로를 찾는 알고리즘이다. 그래서 길 찾기 문제라고도 불린다. 최단경로 알고리즘 유형에는 다양한 종류가 있는데, 상황에 맞는 효율적인 알고리즘이 이미 정립되어 있으므로 잘 기억하자.
	* 최단경로 문제는 보통 그래프를 이용해 표현하는데 각 지점은 그래프에서 노드로 표현되고, 지점간 연결된 도로는 그래프에서 간선으로 표현이 된다.

### 9. 최단경로 - 다익스트라(dijkstra) 알고리즘
* 다익스트라 알고리즘
	* 다익스트라 최단경로 알고리즘은 그래프에서 여러개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘이다. 다익스트라 알고리즘은 음의간선이 없을 때 정상적으로 동작한다.
	* 다익슥트라의 경우 방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 선택하는 과정을 반복하는데 이렇게 진행하면서 한 단계당 하나의 노드에 대한 최단거리를 확실하게 찾을수가 있다.

* 다익스트라 알고리즘 동작과정
	* 출발 노드를 설정한다.
	* 최단 거리 테이블을 초기화한다.
	* 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.
	* 해당 노드를 거쳐 다른노드로 가는 비용을 계산하여 최단 거리 테이블을 업데이트한다.
	* 3번과 4번과정을 반복한다.

* 다익스트라 알고리즘 - O(V^2)
	* V : 노드의 개수
	* O(V)번에 걸쳐서 최단거리가 가장 짧은 노드를 매번 선형탐색해야 하며, 현재 노드와 연결된 노드를 매번 일일이 확인하기 때문에 O(V^2)이다.
	* 이처럼 구현을 하게 될시 노드의 개수가 5,000개 이하라면 일반적으로 잘 동작한다.

* 다익스트라 알고리즘 - O(ElogV)
	* V : 노드의 개수, E : 간선의 개수
	* 위와 같이 O(V^2)이지만 우선순위큐를 이용하여 O(ElogV)를 보장하여 해결할 수 있다.
	* 최단거리가 가장 짧은 노드를 단순히 선형적으로 찾는것이 아닌 더욱더 빠르게 찾는 방법으로 시간복잡도를 줄인다.
	* 힙(Heap) 자료구조의 우선순위 큐를 이용한다. 우선순위 큐는 가장 높은(작은) 데이터를 가장먼저 삭제한다는 점이 있다.
	* Python에서는 heapq라이브러리를 이용하여 우선순위큐를 사용한다. 파이썬에서는 default로 가장 작은 값을 찾아준다. 역으로 가장 큰값을 찾기위해 값에다가 -를 붙여서 사용하기도 한다.
	* () 튜플구조로 넣게 될경우 0번째 인덱스를 기준으로 가장 작은 값을 처리한다.
	* 힙(Heap)을 이용한 우선순위 큐 시간복잡도는 O(logN)이다.
	* 위의 O(V^2)에서 최단거리가 가장 짧은 노드를 선택하는 과정을 우선순위 큐를 이용하는 방식으로 대체한것이다.
	* 개선된 다익스트라 알고리즘의 시간복잡도는 O(ElogV)이다.

### 10. 최단경로 - 플로이드 워셜(Floyd-Warshall) 알고리즘
* 플로이드 워셜 알고리즘
	* 이전 다익스트라 알고리즘은 한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우에 사용할 수가 있다.
	* 플로이드 워셜 알고리즘 같은 경우에는 모든 지점에서 다른 모든 지점까지의.최단 경로를 모두 구해야 하는 경우 사용할 수 있다.
	* 단계마다 거쳐가는 노드를 기준으로 알고리즘을 수행한다.
	* 노드의 개수가 N개일 때 알고리즘 상으로 N번의 단계를 수행하며, 단계마다 O(N^2)의 연산을 통해 현재 노드를 거쳐가는 모든 경로를 고려한다. 따라서 플로이드 워셜 알고리즘의 총 시간 복잡도는 O(N^3)이다.
	* 다익스트라 알고리즘은 그리디 알고리즘이지만, 플로이드 워셜 알고리즘은 다이나믹 프로그래밍이라는 특징이 있다. 노드의 개수가 N이라고 할 때, N만큼 단계를 반복하며 점화식에 맞게 2차원 리스트를 갱신하기 때문에 다이나믹 프로그래밍으로 볼수가 있다.

### 11. 최단경로 - 벨만포드(Bellman-Ford) 알고리즘
* 벨만포드 알고리즘
	* 벨만포드 알고리즘의 경우 방향이 있는 그래프에서, 음의 가중치가 있을 때 최단경로를 알수가 있습니다.
	* 만약 간선이 음의 가중치를 가지면서, 그 구간이 순환구조를 띄는 경우 최단경로를 구할수가 없다.
	* 벨만포드 알고리즘은 정점의 개수만큼 모든 간선을 Relax하는 작업을 수행한다. 기본적으로 돌아가는 최단거리가 업데이트되는 과정은 다익스트라와 유사하다. 다만 양의 가중치를 가지는 다익스트라와는 달리 벨만포드 알고리즘은 음의 가중치도 가질수가 있다.
	* 음의 사이클(Negative cycle)이 도는 경우 해당 정점의 이동 간선을 보면, 양의 가중치보다 음의 가중치의 절대값이 더 큰것을 볼 수가 있다.
	* 시간복잡도의 경우 다익스트라O(VlogV)에 비해 O(VE)로 좀 더 시간이 오래 걸리는 것을 볼 수가 있다.

* 벨만포드 참고 블로그
	* [자료참고 : 벨만포드 참고 블로그1](https://victorydntmd.tistory.com/104)
	* [자료참고 : 벨만포드 참고 블로그2](https://velog.io/@adorno10/%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C-2-%EB%B2%A8%EB%A7%8C-%ED%8F%AC%EB%93%9CBellman-Ford-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
	* [자료참고 : 벨만포드 참고 블로그3](https://blog.naver.com/PostView.nhn?blogId=adamdoha&logNo=222078221541)

### 12. 그래프 알고리즘 - 서로소 집합(Disjoint Sets)
* 서로소 집합 알고리즘
	* 공통원소가 없는 두 집합을 의미한다.
	* 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조이다.
	* 서로소 집합 자료구조는 Union과 Find이 2개의 연산으로 조작할 수 있다.
	* Union 함수 : 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산이다.
	* Find 함수 : 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산이다.

* 서로소 집합 자료구조 동작
	* Union연산을 확인하여, 서로 연결된 두 노드 A, B를 확인한다.
	* A와B의 루트노드를 각각 찾는다.
	* A를 B의 부모노드로 설정한다.
	* 위의 모든 Union연산을 다할때 까지 반복한다.

* 서로소 집합 자료구조
	* 일반적으로 A와B가 있다면 더 번호가 작은 원소가 부모 노드가 되도록 구현하는 경우가 많다.
	* 실제로 루트를 확인하고자 할때는 재귀적으로 부모를 거슬러 올라가서 최종적인 루트 노드를 찾아야한다.

* 서로소 집합 자료구조 시간복잡도
	* find함수에 따라 시간복잡도가 달라진다.
	* 일반적은 부모노드를 거슬러 올라가는 코드의 경우 시간복잡도가 O(VM)이지만, 경로압축을 통하여 구현을 하게 될경우 O(V + MlogV)가 된다.

* 서로소 집합을 이용한 사이클 판별
	* 서로소 집합은 무방향그래프 내에서의 사이클을 판별할 때 사용할 수 있다.
	* 방향그래프에서는 DFS를 통해 판별할 수 있다.

* 사이클 판변 동작
	* 각 간선을 확인하며 두 노드의 루트 노드를 확인한다.
	* 루트노드가 서로 다르다면 두 노드에 대하여 Union연산을 수행한다.
	* 루트노드가 서로 같다면 사이클이 발생!! 아니면 Union연산을 그래프에 포함되어 있는 모든 간선에 대해 반복한다.

### 13. 신장트리 알고리즘 - 크루스칼(Kruskal) 알고리즘 
* 신장트리(Spanning) 알고리즘
	* 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미한다. 이때 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다는 조건은 트리의 성립조건이기도 하다.

* 크루스칼 알고리즘
	* 최소한의 비용으로 신장트리를 찾아야 할 때 사용하기 좋은 알고리즘이다.
	* 이처럼 신장트리 중에서 최소비용으로 만들 수 있는 신장트리를 찾는 알고리즘을 최소신장트리 알고리즘이라고 한다.
	* 크루스칼 알고리즘을 사용하면 가장 적은 비용으로 모든 노드를 연결 할 수가있다. 따라서 크루스칼 알고리즘은 그리디 알고리즘을 분류가 된다.
	* 모든 간선에 대하여 정렬을 수행한 뒤 가장 거리가 짦은 간선부터 집합에 포함시키며 이떄 사이클을 발생시킬 수 있는 간선의 경우, 집합에 포함시키지 않는다. 
	* 최소신장트리는 일종의 트리 자료구조이므로, 최종적으로 신장트리에 포함되는 간선의 개수가 노드의 개수 - 1과 같다는 특징이 있다. 
	* 크루스칼 알고리즘의 경우 거리가 가장 짧은 간선부터 차례대로 집합에 추가하면 된다. 다만 사이클을 발생시키는 간선은 제외한다.

* 크루스칼 알고리즘 동작
	* 간선 데이터를 비용에 따라 오름차순으로 정렬한다.
	* 간선을 하나씩 환인하며 현재의 간선이 사이클을 발생시키는지 확인한다.
	* 사이클이 발생하지 않는 경우 최소신장트리에 포함시킨다.
	* 사이클이 발생하는 경우 최소신장트리에 포함시키지 않는다.
	* 모든 간선에 대해 위의 과정을 반복한다.

* 크루스칼 알고리즘의 시간복잡도
	* 크루스칼 알고리즘은 간선의 개수가 E개일 때, O(ElogE)의 시간복잡도를 가진다. 왜냐하면 크루스칼 알고리즘에서 시간이 가장 오래 걸리는 부분이 간선을 정렬하는 작업이며, E개의 데이터를 정렬했을 때의 시간복잡도는 O(ElogE)이기 때문이다. 여기서 크루스칼 내부 알고리즘에서 사용되는 서로소집합 알고리즘의 경우 정렬 알고리즘의 시간복잡도보다 작으므로 무시해도 된다.

### 14. 신장트리 알고리즘 - 프림(Prim) 알고리즘
* 프림 알고리즘
	* 프림 알고리즘도 크루스칼 알고리즘과 같이 그래프 상에서 정점과 정점사이의 경로의 합이 최소가 되도록 그래프를 만드는 알고리즘이다.
	* 프림 알고리즘의 경우 시간복잡도가 O(V^2)으로 O(E log(E)인 크루스칼 알고리즘보다 느리지만 간선의 개수가 많은 경우 프림알고리즘을 사용하는 것이 좋다. 반대로 간선의 개수가 적으면 크루스칼 알고리즘을 적용하면 효율적이다.

* 프림 알고리즘 참고 블로그
	* [자료참고 : 프림 알고리즘 참고 블로그1] (http://ehpub.co.kr/8-3-%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%B5%9C%EC%86%8C%EC%8B%A0%EC%9E%A5%ED%8A%B8%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/)
	* [자료참고 : 프림 알고리즘 참고 블로그2](https://sexy-developer.tistory.com/58#recentEntries)

### 15. 위상정렬(Topology Sort)
* 위상정렬
	* 위상정렬은 정렬알고리즘의 일종으로, 순서가 정해져있는 일련의 작업을 차례대로 수행해야 할 때 사용할 수 있는 알고리즘이다.
	* 위상정렬이란 방향그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것이다.
	* 방향이 있는 그래프 상에서 선후 관계가 있다면, 위상정렬을 수행하여 모든 선후 관계를 지키는 전체 순서를 계산할 수 있다.

* 진입차수(Indegree)
	* 진입차수란 특정한 노드로 들어오는 간선의 개수를 말한다.

* 위상정렬 동작
	* 진입차수가 0인 노드를 큐에 넣는다.
	* 큐가 빌 때까지 다음의 과정을 반복한다.
	* 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.
	* 새롭게 진입차수가 0이된 노드를 큐에 넣는다.
	* 만약 반복하는 과정에서 모든 원소를 방문하기전에 큐가 비어버리게 되는 경우 사이클이 존재한다고 판단할 수 있다. 큐에서 모든 원소를 확인하기 전에 큐가 비어버리면 사이클이 발생한것이다.
	* 위상정렬의 경우 큐에서 빠져나간 노드를 순서대로 출력하면, 그게 위상정렬을 수행한 결과가 되는데 따라서 진입차수가 같은 경우가 존재할시 정답은 여러개가 될수가 있다.

* 위상정렬의 시간복잡도
	* 위상정렬의 시간복잡도는 O(V + E)이다. 위상정렬을 수행할 떄는 차례대로 모든 노드를 확인하면서, 해당 노드에서 간선을 차례대로 제거해야하기 때문에 결과적으로 모든 노드와 간선을 확인하게 된다. 따라서 O(V + E)의 시간이 소요된다.	

---

[자료참조 : 이것이 취업을 위한 코딩테스트다](https://blog.naver.com/ndb796)

