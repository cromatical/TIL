### 1. Greedy(그리디)
* 탐욕적으로 문제를 해결하는 알고리즘.
* **'현재 상황에서 지금 당장 좋은 것만 고르는 방법'** 
* 그리디 알고리즘을 이용하면 매 순간 가장 좋아 보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.
* 다익스트라 알고리즘도 엄밀히 말하면 그리디 알고리즘이다.
* 특정문제를 보았을 때 단순 현재 상황에서 가장 좋아보이는 것만을 선택해도 문제를 풀수 있는지를 파악할 수 있어야 한다.
* 문제에서 **'가장 큰 순서대로'**, **'가장 작은 순서대로'** 기준을 제시해준다.
* 그리디 알고리즘은 자주 **정렬 알고리즘**과 짝을 이뤄 출제가 된다.

### 2. 구현
* 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
* 모든 경우의 수를 주저 없이 다 계산하는 해결 방법을 완전 탐색이라 한다.
* 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행해야 하는 문제 유형을 시뮬레이션이라고 한다.
* 구현시 고려해야할 사항으로 C/C++에서는 메모리 제약사항과 파이썬에서는 리스트의 크기를 신경써줘야 한다.

### 3. 자료구조의 기초
* 탐색(Search) : 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
	* 그래프, 트리 등의 자료구조를 말하며 DFS, BFS가 대표적인 탐색 알고리즘이다.
* 자료구조(Data Structure) : 데이터를 표현하고 관리하고 처리하기 위한 구조
	* 스택, 큐가 자료구조의 기초 개념이며 삽입과 삭제가 핵심적인 함수로 구성된다.
	* 스택과 큐를 사용할 때는 삽입(Push)과 삭제(Pop) 외에서 오버플로와 언더플로를 고민해줘야 한다
	* 오버플로(Overflow) : 자료구조가 수용할 수 있는 데이터의 크기를 이미 가득 찬 상태에서 삽입연산을 수행할 때 발생
	* 언더플로(Underflow) : 자료구조에 데이터가 전혀 들어 있지 않은 상태에서 삭제 연산을 수행하면 데이터가 전혀 없는 상태이므로 언더플로가 발생한다.

* 스택(Stack) : 선입후출(FILO)구조 또는 후입선출(LIFO)구조를 말한다.
	* 파이썬에서는 스택을 이용할 때 별도의 라이브러리를 사용할 필요가 없다.
	* 기본 리스트에서 append() 와 pop()을 이용하면 스택 자료구조와 동일하게 동작한다.

* 큐(Queue) : 선입선출(FIFO)구조이다.
	* 파이썬에서 큐를 구현할 때는 collections 모듈에서 제공하는 deque 자료구조를 활용하자.

* 재귀함수(Recursive) : 자기 자신을 다시 호출하는 함수를 의미한다.
	* 재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수가 언제 끝날지, 종료 조건을 꼭 명시해야 한다. 종료조건을 명시하지 않으면 함수가 무한 호출이 될 수 있다.
	* 재귀함수는 내부적으로 스택 자료구조와 동일하다.
	* 재귀함수는 반복문을 이용하는 것과 비교하였을 대 보다 간결해진다.

### 4. 탐색알고리즘 DFS / BFS
* 그래프(Graph)의 기본 구조
	* 그래프는 노드(Node)와 간선(Edge)로 표현되며, 이때 노드를 정점(Vertex)이라고 말한다.
	* 인접 행렬(Adjacency Matrix) : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
	* 인접 리스트(Adjacency List) : 리스트로 그래프의 연결 관계를 표현하는 방식
	* 인접 행렬 방식은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비가 된다.
	* 인접리스트 방식은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용한다.
	* 인접리스트는 두 노드가 연결되었는지에 대한 정보를 얻는 속도가 느리다. 왜냐하면 하나하나 연결된 데이터를 하나씩 확인해야하기 때문이다.
	* 모든 인접 노드를 순회해야 하는 경우, 인접리스트방식이 인접 행렬 방식에 비해 메모리 공간의 낭비가 적다.

* DFS(Depth First Search) 깊이우선탐색 알고리즘
	* 깊이 우선 탐색 알고리즘은 DFS는 스택 자료구조에 기초한다.
	* 시간복잡도는 O(N)이다.	
	* 스택을 이용하는 알고리즘이기 때문에 실제 구현은 재귀함수를 이용하면 매우 간결하게 구현할 수 있다.

~~~
1. 탐색 시작 노드를 스택에 삽입하고 방문처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있다면 그 인접 노드를 스택에 넣고 방문처리를 한다. 방문하지 않은 인접노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번의 과정을 더이상 수행할 수 없을 때까지 반복한다.
~~~

* BFS(Breadth First Search) 너비우선탐색 알고리즘
	* 가까운 노드부터 탐색하는 알고리즘이다.
	* 선입선출(FIFO)방식인 큐 자료구조를 이용하는 것이 정석이다.
	* deque 라이브러리를 사용하는것이 좋으며 탐색을 수행함에 있어 O(N)의 시간이 소요된다.
	* 실제 수행 시간은 DFS보다 좋은편이다.

~~~
1. 탐색 시작 노드를 큐에 삽입하고 방문처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다. 
~~~


### 5. 기준에 따라 데이터를 정렬
* 정렬 알고리즘 개요
	* 정렬(Sorting) : 데이터를 특정한 기준에 따라서 순서대로 나열하는것을 말한다.  
	* 프로그램에서 데이터를 가공할 때 오름차순, 내림차순으로 정렬해서 사용하는 경우가 많다.
	* 정렬 알고리즘으로 데이터를 정렬하면 이진탐색(Binary Search)이 가능해진다.
	* 종류 : 선택정렬, 삽입정렬, 퀵정렬, 계수정렬 등
	* 면접에서도 단골로 굉장히 자주 나온다.

* 선택정렬(Selection Sort)
	* 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두번째 데이터와 바꾸는 과정을 통해 점점 작은 데이터를 앞에 두는 알고리즘이다.
	* 가장 원시적인 방법이며, 매번 가장 작은것을 선택한다.
	* 시간복잡도는 O(N^2)이다.

* 삽입정렬(Insertion Sort)
	* 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하는 알고리즘이다.
	* 삽입정렬은 필요할 때만 위치를 바꾸므로 '데이터가 거의 정렬 되었을 때' 효율적이다.
	* 정렬이 이루어진 원소는 항상 오름차순을 유지하고 있다.
	* 자기보다 작은 데이터를 만나면 더 이상 데이터를 살펴보지 않고 그 자리에 삽입한다.
	* 시간복잡도는 O(N^2)이지만, 거의 정렬되어 있는 경우 다른 알고리즘 보다 강력한 O(N)의 시간복잡도를 가진다.

* 퀵정렬(Quick Sort)
	* 지금까지 나온 정렬 알고리즘 중에서 가장많이 사용되는 알고리즘이다.
	* 퀵정렬과 비교할 만큼 빠른 '병합정렬' 알고리즘이 있다.
	* 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾼후 리스트를 반으로 나누는 방식을 퀵정렬 알고리즘이라고 한다. 
	* 기준 데이터를 피벗(Pivot)이라고 부른다.
	* 특정한 리스트에서 피벗을 설정하여 정렬을 수행한 후, 다시 피벗을 기준으로 왼쪽 리스트와 오른쪽 리스트에서 각각 다시 정렬을 수행한다. 이 과정은 '재귀함수' 동작 원리와 같다. 끝나는 조건은 리스트의 데이터 개수가 1개인 경우 재귀가 멈춘다.
	* 퀵정렬의 시간복잡도는 O(NlogN)이지만 최악의 경우 O(N^2)이다.
	* 최악의 경우에는 이미 리스트가 정렬이 되어있는 경우를 말한다.

* 계수정렬(Count Sort)
	* 다음과 같은 특정한 조건에 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.
	* 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용할 수 있다.
	* 일반적으로는 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용이 가능하다.
	* 계수정렬은 모든 범위를 담을 수 있는 크기의 배열을 미리 선언한다.
	* 계수정렬의 시간복잡도는 O(N+K)이다. 조건에만 부합하다면 현존하는 정렬 알고리즘 중 기수정렬(Radix Sort)과 더불어 가장 빠르다.
	* 기수정렬의 경우 계수정렬에 비해 동작은 느리지만 처리할 수 있는 정수의 크기가 더 크다.
	* 계수정렬의 공간복잡도는 O(N+K)이다. 문제에 따라서 동일한 값을 가지는 데이터가 여러개일 경우 효과적으로 동작하지만 극단적으로 0, 999,999와 같은 단 2개만 있다고 한다면 계수정렬에서 리스트의 크기가 100만개가 되어야 하므로 항상 사용할 수 있는 정렬 알고리즘은 아니며 상황을 보며 써야한다.

* 파이썬에서 제공하는 정렬 라이브러리
	* 기본으로 제공하는 정렬라이브러리인 sorted()함수는 퀵정렬과 동작방식이 비슷한 병합정렬을 기반으로 만들어져서 일반적인 퀵정렬보다는 느리지만 최악의 경우에도 O(NlogN)시간복잡도를 보장한다.

* 코딩테스트에서의 정렬
	* 정렬 라이브러리로 풀 수 있는 문제 : 단순히 정렬 기법을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용법을 숙지하면 쉽게 해결한다.
	* 정렬 알고리즘의 원리에 대해서 물어보는 문제 : 선택정렬, 삽입정렬, 퀵정렬 등의 원리를 알아야 풀 수 있다.
	* 더 빠른 정렬이 필요한 문제 : 퀵정렬 기반의 정렬 기법으로는 풀 수가 없으며, 계수정렬 등의 다른 알고리즘을 사용하거나 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.

### 6. 이진탐색
* 순차탐색(Sequential Search)
	* 가장 기본적인 탐색 방법이다. 
	* 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법이다.
	* 보통 정렬되지 않은 리스트에서 데이터를 찾아야 할 때 사용한다. 
	* 리스트의 데이터에 하나씩 방문하며 특정한 문자열과 같은지 검사하므로 구현도 간단하다.
	* 리스트에 특정 값의 원소가 있는지 체크할 때 순차탐색으로 원소를 확인한다.
	* 리스트 자료형에서 특정한 값을 가지는 원소의 개수를 세는 count메서드를 이용할 때도 내부에서는 순차탐색이 수행된다.
	* 정렬 여부와 상관없이 가장 앞에 있는 원소부터 하나씩 확인해야 한다는 점이 특징.
	* 데이터의 개수가 N개일 때 최대 N번의 비교 연산이 필요하므로 순차탐색의 최악의 경우 시간복잡도는 O(N)이다.

* 이진탐색(Binary Search) : 반으로 쪼개면서 탐색하기
	* 배열 내부의 데이터가 정렬되어 있어야만 사용할 수 있다.
	* 이미 정렬되어 있다면 매우 빠르게 데이터를 찾을 수 있다는 특징이 있다.
	* 이진 탐색은 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 특징이 있다.
	* 변수 3개를 사용한다. 시작점, 중간점, 끝점.
	* 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를  찾는 게 이진탐색 과정이다.
	* 확인하는 원소의 개수가 절반씩 줄어든다는 점에서 시간복잡도는 O(logN)이다.
	* 이진탐색을 구현하는 방법에는 2가지 방법이 있다.
		1. 재귀함수 이용.
		2. 단순하게 반복문을 이용.

* 트리자료구조 : 트리 자료구조 중에서 가장 간단한 형태가 이진탐색트리이다.
	* 트리는 부모노드와 자식노드의 관계로 표현된다.
	* 트리의 최상단 노드를 루트 노드라고 한다.
	* 트리의 최하단 노드를 단말 노드라고 한다.
	* 트리에서 일부를 떼어내도 트리 구조이며 이를 버스트리라 한다.
	* 트리는 파일 시스템과 같이 계층적이고 정렬된 데이터를 다루기에 적합하다.

* 빠르게 입력받기
	* 입력데이터의 개수가 많은 문제에 input()을 사용하면 동작속도가 느려서 시간초과로 오답판정을 받을 수가 있다.
	* 이때 sys라이브러리의 readline()함수를 이용하면 시간초과를 피할 수 있다.
	* readline()으로 입력하게 되면 엔터가 개행으로 입력된다. 이때 rstrip()함수를 통해서 마지막 개행을 제거해줘야한다.
~~~
import sys

input_data = sys.stdin.readline().rstrip()

print(input_data)
~~~

### 7.다이나믹 프로그래밍(Dynamic Programming) - 중복되는 연산을 줄이자!
* 컴퓨터를 활용해도 해결하기 어려운 문제란?!
	* 최적의 해를 구하기에 시간이 매우 많이 필요할때
	* 메모리 공간이 매우 많이 필요한 문제
	=> 컴퓨터도 연산속도에 한계가 있으며 메모리 공간을 사용할 수 있는 데이터의 개수도 한정적이다.!! 따라서 속도와 공간을 최대한 활용하는 효율적인 알고리즘을 사용해야 한다.

* 다이나믹 프로그래밍은 다음조건을 만족할 때 사용할 수 있다.
	* 큰 문제를 작은 문제로 나눌수 있는 경우
	* 작은 문제에서 구한 정답이 큰 문제를 해결하고자 동일하게 쓰이는 경우

* 메모이제이션(Memoization) 기법
	* 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, 한 번 구한 결과를 메모리 공간에 저장해두고 같은 식을 다시 호출하는 알고리즘 방법
	* 메모이제이션은 값을 저장하는 방법이므로 캐싱(Caching)이라고 한다.

* 분할정복(Divide and Conquer)과 다이나믹 프로그래밍의 차이점
	* 다이나믹 프로그래밍 문제는 서로 영향을 미친다.
	* ex) 퀵정렬을 예로 한번 기준 원소(pivot)의 자리를 변경해서 자리를 잡게 되면 그 기준원소의 위치는 더 이상 바뀌지 않고 그 피벗값을 다시 처리하는 부분 문제는 존재하지 않는다. 하지만 다이나믹 프로그래밍은 한 번 해결했던 문제를 저장을 해두고 필요에 따라 문제를 다시 해결한다는 점이있다.

* 다이나믹 프로그래밍의 시간복잡도
	* 다이나믹 프로그래밍에서 재귀 함수를 사용하면 컴퓨터 시스템에서는 함수를 다시 호출했을 때 메모리상에 적재되는 일련의 과정을 따라야 하므로 오버헤드가 발생할 수 있다.
	* 일반적으로 반복문을 이용한 다이나믹 프로그래밍이 더 성능이 좋다.
	* 다이나믹 프로그래밍을 적용했을 때 시간복잡도는 O(N)이다.

* 다이나믹 프로그래밍의 종류
	* 탑다운(Top-Down) : 큰 문제를 해결하기 위해 작은 문제를 호출하여 접근하는 방법
	* 보텀업(Botton-Up) : 작은 문제부터 차근차근 답을 도출하여 접근하는 방법
	* 탑다운의 경우 보통 재귀방식이고 보텀업의 경우는 반복문을 이용한다.
	* 탑다운의 경우 메모이제이션(Memoization)이라고 하양식이로고도 하며, 보텀업은 상향식이라고 한다.
	* 탑다운방식에서 사용되는 결과 저장용 리스트는 메모이제이션이라고 한다.
	* 보텀업방식에서 사용되는 결과 저장용 리스트는 DP테이블이라고 한다.

* 코딩테스트에서의 다이나믹 프로그래밍
	* 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인해보자
	* 가능하다면 재귀함수를 이용하는 탑다운 방식보다는 보텀업 방식으로 구현하는게 권장이된다. 시스템상 재귀 함수의 스택크기가 한정되어 있기 때문이다.
	* 파이썬에서 재귀함수를 5000이상의 깊이로 구현할 경우 깊이(Depth)와 관련된 오류가 발생할 수 있다. 그럴경우 sys라이브러리에 있는 setrecursionlimit()함수를 호출하여 재귀 제한을 완화시키자.

### 8. 최단경로(Shortest Path) 알고리즘
* 가장 빠르게 도달하는 방법
	* 최단경로 알고리즘은 말 그대로 가장 짧은 경로를 찾는 알고리즘이다. 그래서 길 찾기 문제라고도 불린다. 최단경로 알고리즘 유형에는 다양한 종류가 있는데, 상황에 맞는 효율적인 알고리즘이 이미 정립되어 있으므로 잘 기억하자.
	* 최단경로 문제는 보통 그래프를 이용해 표현하는데 각 지점은 그래프에서 노드로 표현되고, 지점간 연결된 도로는 그래프에서 간선으로 표현이 된다.

### 9. 최단경로 - 다익스트라(dijkstra) 알고리즘
* 다익스트라 알고리즘
	* 다익스트라 최단경로 알고리즘은 그래프에서 여러개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘이다. 다익스트라 알고리즘은 음의간선이 없을 때 정상적으로 동작한다.
	* 다익슥트라의 경우 방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 선택하는 과정을 반복하는데 이렇게 진행하면서 한 단계당 하나의 노드에 대한 최단거리를 확실하게 찾을수가 있다.

* 다익스트라 알고리즘 동작과정
	* 출발 노드를 설정한다.
	* 최단 거리 테이블을 초기화한다.
	* 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.
	* 해당 노드를 거쳐 다른노드로 가는 비용을 계산하여 최단 거리 테이블을 업데이트한다.
	* 3번과 4번과정을 반복한다.

* 다익스트라 알고리즘 - O(V^2)
	* V : 노드의 개수
	* O(V)번에 걸쳐서 최단거리가 가장 짧은 노드를 매번 선형탐색해야 하며, 현재 노드와 연결된 노드를 매번 일일이 확인하기 때문에 O(V^2)이다.
	* 이처럼 구현을 하게 될시 노드의 개수가 5,000개 이하라면 일반적으로 잘 동작한다.

* 다익스트라 알고리즘 - O(ElogV)
	* V : 노드의 개수, E : 간선의 개수
	* 위와 같이 O(V^2)이지만 우선순위큐를 이용하여 O(ElogV)를 보장하여 해결할 수 있다.
	* 최단거리가 가장 짧은 노드를 단순히 선형적으로 찾는것이 아닌 더욱더 빠르게 찾는 방법으로 시간복잡도를 줄인다.
	* 힙(Heap) 자료구조의 우선순위 큐를 이용한다. 우선순위 큐는 가장 높은(작은) 데이터를 가장먼저 삭제한다는 점이 있다.
	* Python에서는 heapq라이브러리를 이용하여 우선순위큐를 사용한다. 파이썬에서는 default로 가장 작은 값을 찾아준다. 역으로 가장 큰값을 찾기위해 값에다가 -를 붙여서 사용하기도 한다.
	* () 튜플구조로 넣게 될경우 0번째 인덱스를 기준으로 가장 작은 값을 처리한다.
	* 힙(Heap)을 이용한 우선순위 큐 시간복잡도는 O(logN)이다.
	* 위의 O(V^2)에서 최단거리가 가장 짧은 노드를 선택하는 과정을 우선순위 큐를 이용하는 방식으로 대체한것이다.
	* 개선된 다익스트라 알고리즘의 시간복잡도는 O(ElogV)이다.

---

[자료참조 : 이것이 취업을 위한 코딩테스트다](https://blog.naver.com/ndb796)
