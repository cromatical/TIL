### 1. Greedy(그리디)
* 탐욕적으로 문제를 해결하는 알고리즘.
* **'현재 상황에서 지금 당장 좋은 것만 고르는 방법'** 
* 그리디 알고리즘을 이용하면 매 순간 가장 좋아 보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.
* 다익스트라 알고리즘도 엄밀히 말하면 그리디 알고리즘이다.
* 특정문제를 보았을 때 단순 현재 상황에서 가장 좋아보이는 것만을 선택해도 문제를 풀수 있는지를 파악할 수 있어야 한다.
* 문제에서 **'가장 큰 순서대로'**, **'가장 작은 순서대로'** 기준을 제시해준다.
* 그리디 알고리즘은 자주 **정렬 알고리즘**과 짝을 이뤄 출제가 된다.

### 2. 구현
* 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
* 모든 경우의 수를 주저 없이 다 계산하는 해결 방법을 완전 탐색이라 한다.
* 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행해야 하는 문제 유형을 시뮬레이션이라고 한다.
* 구현시 고려해야할 사항으로 C/C++에서는 메모리 제약사항과 파이썬에서는 리스트의 크기를 신경써줘야 한다.

### 3. 자료구조의 기초
* 탐색(Search) : 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
	* 그래프, 트리 등의 자료구조를 말하며 DFS, BFS가 대표적인 탐색 알고리즘이다.
* 자료구조(Data Structure) : 데이터를 표현하고 관리하고 처리하기 위한 구조
	* 스택, 큐가 자료구조의 기초 개념이며 삽입과 삭제가 핵심적인 함수로 구성된다.
	* 스택과 큐를 사용할 때는 삽입(Push)과 삭제(Pop) 외에서 오버플로와 언더플로를 고민해줘야 한다
	* 오버플로(Overflow) : 자료구조가 수용할 수 있는 데이터의 크기를 이미 가득 찬 상태에서 삽입연산을 수행할 때 발생
	* 언더플로(Underflow) : 자료구조에 데이터가 전혀 들어 있지 않은 상태에서 삭제 연산을 수행하면 데이터가 전혀 없는 상태이므로 언더플로가 발생한다.

* 스택(Stack) : 선입후출(FILO)구조 또는 후입선출(LIFO)구조를 말한다.
	* 파이썬에서는 스택을 이용할 때 별도의 라이브러리를 사용할 필요가 없다.
	* 기본 리스트에서 append() 와 pop()을 이용하면 스택 자료구조와 동일하게 동작한다.

* 큐(Queue) : 선입선출(FIFO)구조이다.
	* 파이썬에서 큐를 구현할 때는 collections 모듈에서 제공하는 deque 자료구조를 활용하자.

* 재귀함수(Recursive) : 자기 자신을 다시 호출하는 함수를 의미한다.
	* 재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수가 언제 끝날지, 종료 조건을 꼭 명시해야 한다. 종료조건을 명시하지 않으면 함수가 무한 호출이 될 수 있다.
	* 재귀함수는 내부적으로 스택 자료구조와 동일하다.
	* 재귀함수는 반복문을 이용하는 것과 비교하였을 대 보다 간결해진다.

### 4. 탐색알고리즘 DFS / BFS
* 그래프(Graph)의 기본 구조
	* 그래프는 노드(Node)와 간선(Edge)로 표현되며, 이때 노드를 정점(Vertex)이라고 말한다.
	* 인접 행렬(Adjacency Matrix) : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
	* 인접 리스트(Adjacency List) : 리스트로 그래프의 연결 관계를 표현하는 방식
	* 인접 행렬 방식은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비가 된다.
	* 인접리스트 방식은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용한다.
	* 인접리스트는 두 노드가 연결되었는지에 대한 정보를 얻는 속도가 느리다. 왜냐하면 하나하나 연결된 데이터를 하나씩 확인해야하기 때문이다.
	* 모든 인접 노드를 순회해야 하는 경우, 인접리스트방식이 인접 행렬 방식에 비해 메모리 공간의 낭비가 적다.

* DFS(Depth First Search) 깊이우선탐색 알고리즘
	* 깊이 우선 탐색 알고리즘은 DFS는 스택 자료구조에 기초한다.
	* 시간복잡도는 O(N)이다.	
	* 스택을 이용하는 알고리즘이기 때문에 실제 구현은 재귀함수를 이용하면 매우 간결하게 구현할 수 있다.

~~~
1. 탐색 시작 노드를 스택에 삽입하고 방문처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있다면 그 인접 노드를 스택에 넣고 방문처리를 한다. 방문하지 않은 인접노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번의 과정을 더이상 수행할 수 없을 때까지 반복한다.
~~~

* BFS(Breadth First Search) 너비우선탐색 알고리즘
	* 가까운 노드부터 탐색하는 알고리즘이다.
	* 선입선출(FIFO)방식인 큐 자료구조를 이용하는 것이 정석이다.
	* deque 라이브러리를 사용하는것이 좋으며 탐색을 수행함에 있어 O(N)의 시간이 소요된다.
	* 실제 수행 시간은 DFS보다 좋은편이다.

~~~
1. 탐색 시작 노드를 큐에 삽입하고 방문처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다. 
~~~

---

[자료참조 : 이것이 취업을 위한 코딩테스트다](https://blog.naver.com/ndb796)
